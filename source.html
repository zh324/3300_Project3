<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - catmull spline editor</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				top: 0px;
				width: 100%;
				padding: 5px;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
			}
		</style>
	</head>
	<body>
		<div id="container" width="2000" height="2000"></div>
		<!-- <div id="distInfo"></div> -->


		<script src="three.js-master/build/three.js"></script>
		<script src="https://d3js.org/d3.v4.min.js"></script>

		<script src="js/DragControls.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/TransformControls.js"></script>
		<script src="js/three.interaction.js"></script>

		<script src="js/stats.min.js"></script>
		<script src="js/dat.gui.min.js"></script>
		<script src="js/utils.js"></script>
		<script src="js/textures.js"></script>


		<script>

			var hotelData;
			var restaurantData;
			var entertainmentData;
			var buildingObjects = [];
			var positions = [];
			var objectCount = 0;
			var projection = d3.geoMercator()

			//to alignment the coordinate plane
			var xOffset = -1000;
			var yOffset = -7000;
			var scaleFactor = 10000;
			var angle = 33;
			var minX, minY, maxX, maxY;

			var hiding;

			//control
			var container, stats;
			var scene = new THREE.Scene();
			var camera, renderer, raycaster;
			var mouse = new THREE.Vector2(), INTERSECTED;
			var point = new THREE.Vector3();
			var geometry = new THREE.BoxBufferGeometry( 50, 100, 50 );
			var transformControl;
			var ARC_SEGMENTS = 200;
			var splines = {};
			var params = {
				restaurant: {
					include: true,
					price: 100,
					category: {
						chinese: true,
						korean: true,
						american: true,
						indian: true,
						italian: true
					}
				},
				hotel: {
					include: true,
					price: 100,
					category: {
						holiday: true,
						business: true
					}
				},
				entertainment: {
					include: true,
					price: 100,
					category: {
						movie: true,
						game: true,
						shopping: true
					}
				}
			};


			var spritey;
			var canvas1, context1, texture1;



			// var distInfo = d3.select('#distInfo').append('svg')
			// .style('background', 'white')
			// .attr("id", "bar")
			// .attr('width', "600")
			// .attr('height', "165");
			
			// distInfo.append("text")
			// .attr("id","distInit")
			// .attr("x", 50)
			// .attr("y", 100-60)
			// .attr("font-size", "30px")
			// .attr("font-weight", "900")
			// .style("fill", "#1C1B1B")
			// .text("All NYC Public Schools");
			


			//load csv file
			d3.queue()
			.defer(d3.csv, "data/hotels.csv")
			.defer(d3.csv, "data/restaurants.csv")
			.defer(d3.csv, "data/entertainment.csv")
			.await(function(error, data1, data2, data3) {
				if (error) {
					console.error('Oh dear, something went wrong: ' + error);
				}
				else {
					hotelData = data1;
					restaurantData = data2;
					entertainmentData = data3;

					assignCoordinate(hotelData);
					assignCoordinate(restaurantData);
					assignCoordinate(entertainmentData);

					maxX = d3.max(hotelData.map(function(d){return d.coordinate[0];}));
					minX = d3.min(hotelData.map(function(d){return d.coordinate[0];}));
					maxY = d3.max(hotelData.map(function(d){return d.coordinate[1];}));
					minY = d3.min(hotelData.map(function(d){return d.coordinate[1];}));

					scaleData(restaurantData);
					scaleData(hotelData);
					scaleData(entertainmentData);

				}

				init();
				plot();
				animate();

				// function onMouseMove( event ) { 
				// // calculate mouse position in normalized device coordinates 
				// // (-1 to +1) for both components 
				// mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1; 
				// mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1; 
				// } 

				// window.addEventListener( 'mousemove', onMouseMove, false );
				// window.requestAnimationFrame(render);
			});

			function init() {
				container = document.getElementById( 'container' );
				scene.background = new THREE.Color( 0xf0f0f0 );
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100000 );
				camera.position.set( 0, 250, 1000 );
				scene.add( camera );
				scene.add( new THREE.AmbientLight( 0xf0f0f0 ) );

				// add raycaster
				raycaster = new THREE.Raycaster();


				addLightShadow();
				createGUI();

				var planeGeometry = new THREE.PlaneBufferGeometry( 15000, 7000 );
				planeGeometry.rotateX( - Math.PI / 2 );
				var planeMaterial = new THREE.ShadowMaterial( { opacity: 0.2 } );

				//add plane
				var plane = new THREE.Mesh( planeGeometry, planeMaterial );
				plane.position.y = -200;
				plane.receiveShadow = true;
				scene.add( plane );

				//grid helper
				// var helper = new THREE.GridHelper( 15000, 100 );
				// helper.position.y = - 199;
				// helper.material.opacity = 0.25;
				// helper.material.transparent = true;
				// scene.add( helper );

				//render
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				container.appendChild( renderer.domElement );
				
				//stats
				stats = new Stats();
				container.appendChild( stats.dom );

				// Controls
				var controls = new THREE.OrbitControls( camera, renderer.domElement );

				// interaction
				var interaction = new THREE.Interaction(renderer, scene, camera);

				// sprite
				var spritex;				

			}


			function animate() {
				requestAnimationFrame( animate );
				render();
				stats.update();
			}


			function render() {

				renderer.render( scene, camera );				
			}


			function assignCoordinate(data) {
				for (var i = 0; i < data.length; i++) {
					var aa = [data[i].Latitude, data[i].Longitude];
					data[i].coordinate = projection(aa);
				}
			}


			function scaleData(data) {
				for (var i = 0; i < data.length; i++) {
					data[i].coordinate[0] = (data[i].coordinate[0] - minX) / (maxX - minX) * scaleFactor;
					data[i].coordinate[1] = (data[i].coordinate[1] - minY) / (maxY - minY) * scaleFactor;					
					var x = data[i].coordinate[0];
					var y = data[i].coordinate[1];
					var rad = angle * Math.PI/180;
					data[i].coordinate[0] = x * Math.cos(rad) - y * Math.sin(rad) + xOffset;
					data[i].coordinate[1] = y * Math.cos(rad) + x * Math.sin(rad) + yOffset;					
				}
			}


			function addLightShadow() {
				//light and shadow
				var light = new THREE.SpotLight( 0xffffff, 1.5 );
				light.position.set( 0, 1500, 200 );
				light.castShadow = true;
				light.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 70, 1, 200, 2000 ) );
				light.shadow.bias = -0.000222;
				light.shadow.mapSize.width = 1024;
				light.shadow.mapSize.height = 1024;
				scene.add( light );
				spotlight = light;
			}


			function createGUI() {
				//GUI added
				var gui = new dat.GUI();
				var restaurant = gui.addFolder('Restaurants');
				restaurant.add(params.restaurant, 'include').onFinishChange(updatePlot);
				restaurant.add(params.restaurant, 'price', 0, 100).onFinishChange(updatePlot);
				var restaurantCategory = restaurant.addFolder('Restaurant category');
				restaurantCategory.add(params.restaurant.category, 'chinese').name('Chinese').onFinishChange(updatePlot);
				restaurantCategory.add(params.restaurant.category, 'korean').name('Korean').onFinishChange(updatePlot);
				restaurantCategory.add(params.restaurant.category, 'american').name('American').onFinishChange(updatePlot);
				restaurantCategory.add(params.restaurant.category, 'indian').name('Indian').onFinishChange(updatePlot);
				restaurantCategory.add(params.restaurant.category, 'italian').name('Italian').onFinishChange(updatePlot);
				restaurant.open();

				var hotel = gui.addFolder('Hotels');
				hotel.add(params.hotel, 'include').onFinishChange(updatePlot);
				hotel.add(params.hotel, 'price', 0, 100).onFinishChange(updatePlot);
				var hotelCategory = hotel.addFolder('Hotel category');
				hotelCategory.add(params.hotel.category, 'holiday').onFinishChange(updatePlot);
				hotelCategory.add(params.hotel.category, 'business').onFinishChange(updatePlot);
				hotel.open();

				var entertainment = gui.addFolder('Entertainment');
				entertainment.add(params.entertainment, 'include').onFinishChange(updatePlot);
				entertainment.add(params.entertainment, 'price', 0, 100).onFinishChange(updatePlot);
				var entertainmentCategory = entertainment.addFolder('Entertainment category');
				entertainmentCategory.add(params.entertainment.category, 'movie').onFinishChange(updatePlot);
				entertainmentCategory.add(params.entertainment.category, 'game').onFinishChange(updatePlot);
				entertainmentCategory.add(params.entertainment.category, 'shopping').onFinishChange(updatePlot);
				entertainment.open();
				gui.open();
			}


			function addSplineObject(position, name) {
				var material = new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } );
				var object = new THREE.Mesh( geometry, material );

				// var object = createHospital();
				// object.position.y = -200;
				object.position.copy( position );

				object.castShadow = true;
				object.receiveShadow = true;

				object.on('mousedown', function(ev) {
					mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
					mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
					var vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
					vector.unproject( camera );
					var dir = vector.sub( camera.position ).normalize();
					var distance = - camera.position.z / dir.z;
					var pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
					spritex = makeTextSprite( name, { fontsize: 24, borderColor: {r:0, g:0, b:255, a:1.0}} );
					console.log(spritex)
					spritex.position.copy(pos);
					scene.add( spritex );
				});
				object.on('mouseup', function(ev) {
					scene.remove( spritex );
				});

				scene.add( object );
				buildingObjects.push( object );
				return object;
			}


			function plot() {
				for (var i = 0; i < hotelData.length; i++) {
					var object = addSplineObject(new THREE.Vector3(hotelData[i].coordinate[0], -150, hotelData[i].coordinate[1]), hotelData[i]["Company Name"]);
					objectCount++;
					positions.push(object.position);
				}
				for (var i = 0; i < restaurantData.length; i++) {
					var object = addSplineObject(new THREE.Vector3(restaurantData[i].coordinate[0], -150, restaurantData[i].coordinate[1]), restaurantData[i]["Company Name"]);
					objectCount++;
					positions.push(object.position);
				}
				for (var i = 0; i < entertainmentData.length; i++) {
					var object = addSplineObject(new THREE.Vector3(entertainmentData[i].coordinate[0], -150, entertainmentData[i].coordinate[1]), entertainmentData[i]["Company Name"]);			
					objectCount++;
					positions.push(object.position);
				}					
			}


			function updatePlot() {
				removeAllPoints();
				if (params.hotel.include) {
					for (var i = 0; i < hotelData.length; i++) {
						var object = addSplineObject(new THREE.Vector3(hotelData[i].coordinate[0], -150, hotelData[i].coordinate[1]));
						objectCount++;
						positions.push(object.position);
					}
				}
				if (params.restaurant.include) {
					for (var i = 0; i < restaurantData.length; i++) {
						var object = addSplineObject(new THREE.Vector3(restaurantData[i].coordinate[0], -150, restaurantData[i].coordinate[1]));
						objectCount++;
						positions.push(object.position);
					}
				}
				if (params.entertainment.include) {
					for (var i = 0; i < entertainmentData.length; i++) {
						var object = addSplineObject(new THREE.Vector3(entertainmentData[i].coordinate[0], -150, entertainmentData[i].coordinate[1]));			
						objectCount++;
						positions.push(object.position);
					}	
				}				
			}


			function removeAllPoints() {
				if ( objectCount <= 0 ) {
					return;
				}
				for (var i = 0; i < objectCount; i++) {
					positions.pop();
					scene.remove( buildingObjects.pop() );
				}
				objectCount = 0;
			}


			function makeTextSprite( message, parameters ){
			
				if ( parameters === undefined ) parameters = {};
				
				var fontface = parameters.hasOwnProperty("fontface") ? 
					parameters["fontface"] : "Arial";
				
				var fontsize = parameters.hasOwnProperty("fontsize") ? 
					parameters["fontsize"] : 18;
				
				var borderThickness = parameters.hasOwnProperty("borderThickness") ? 
					parameters["borderThickness"] : 4;
				
				var borderColor = parameters.hasOwnProperty("borderColor") ?
					parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };
				
				var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?
					parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };
				// var spriteAlignment = THREE.SpriteAlignment.topLeft;
					
				var canvas = document.createElement('canvas');
				var context = canvas.getContext('2d');
				context.font = "Bold " + fontsize + "px " + fontface;
				
				// get size data (height depends only on font size)
				var metrics = context.measureText( message );
				var textWidth = metrics.width;
				
				// background color
				context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
											+ backgroundColor.b + "," + backgroundColor.a + ")";
				// border color
				context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
											+ borderColor.b + "," + borderColor.a + ")";
				context.lineWidth = borderThickness;
				roundRect(context, borderThickness/2, borderThickness/2, textWidth + borderThickness, fontsize * 1.4 + borderThickness, 6);
				// 1.4 is extra height factor for text below baseline: g,j,p,q.
				
				// text color
				context.fillStyle = "rgba(0, 0, 0, 1.0)";
				context.fillText( message, borderThickness, fontsize + borderThickness);
				
				// canvas contents will be used for a texture
				var texture = new THREE.Texture(canvas) 
				texture.needsUpdate = true;
				var spriteMaterial = new THREE.SpriteMaterial( 
					{ map: texture, useScreenCoordinates: false } );

				var sprite = new THREE.Sprite( spriteMaterial );
				sprite.scale.set(100,50,1.0);
				return sprite;	
			}
			function roundRect(ctx, x, y, w, h, r) 
			{
				ctx.beginPath();
				ctx.moveTo(x+r, y);
				ctx.lineTo(x+w-r, y);
				ctx.quadraticCurveTo(x+w, y, x+w, y+r);
				ctx.lineTo(x+w, y+h-r);
				ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
				ctx.lineTo(x+r, y+h);
				ctx.quadraticCurveTo(x, y+h, x, y+h-r);
				ctx.lineTo(x, y+r);
				ctx.quadraticCurveTo(x, y, x+r, y);
				ctx.closePath();
				ctx.fill();
				ctx.stroke();   
			}





			// addHospital();

			function addHospital() {
				var hospital = createHospital()
				hospital.position.z = -20
				hospital.position.y = -200

				scene.add(hospital)
			}

			function createHospital() {
				var hospital = new THREE.Object3D()

				var baseGeometry = new THREE.BoxBufferGeometry(180, 3, 140)
				var base = utils.makeMesh('lambert', baseGeometry, 0xffffff)
				base.position.y = 1
				hospital.add(base)

				var frontMainCoords = [
				[-80, -30],
				[-80, 20],
				[50, 20],
				[50, 0],
				[20, -30],
				[-80, -30]
				]
				var frontMainShape = utils.makeShape(frontMainCoords)
				var frontMainGeometry = utils.makeExtrudeGeometry(frontMainShape, 100)
				var frontMainMaterial = new THREE.MeshPhongMaterial({ map: textures.window() })
				frontMainMaterial.map.repeat.set(0.1, 0.08)
				var frontMain = new THREE.Mesh(frontMainGeometry, frontMainMaterial)
				frontMain.castShadow = true
				frontMain.receiveShadow = true
				hospital.add(frontMain)

				var frontTopShape = frontMainShape
				var frontTopGeometry = utils.makeExtrudeGeometry(frontTopShape, 5)
				var frontTop = utils.makeMesh('lambert', frontTopGeometry, 0xb1a7af)
				frontTop.position.y = 100
				hospital.add(frontTop)

				var frontRoofShelfGeometry = new THREE.Geometry()
				var frontRoofShelfCubeGeometry = new THREE.BoxGeometry(2, 2, 40)
				// for z-axis
				for (var i = 0; i < 12; i++) {
				var geometry = frontRoofShelfCubeGeometry.clone()
				geometry.translate(i * 5, 0, 0)
				frontRoofShelfGeometry.merge(geometry)
				}
				// for x-axis
				for (var i = 0; i < 2; i++) {
				var geometry = frontRoofShelfCubeGeometry.clone()
				geometry.rotateY(0.5 * Math.PI)
				geometry.scale(1.6, 1, 1)
				geometry.translate(27, 0, -15 + i * 30)
				frontRoofShelfGeometry.merge(geometry)
				}
				// for y-axis
				var frontRoofShelfCubeYPosition = [
				[0, 0],
				[1, 0],
				[0, 1],
				[1, 1]
				]
				for (var i = 0; i < frontRoofShelfCubeYPosition.length; i++) {
				var p = frontRoofShelfCubeYPosition[i]
				var geometry = frontRoofShelfCubeGeometry.clone()
				geometry.scale(1, 1, 0.4)
				geometry.rotateX(0.5 * Math.PI)
				geometry.translate(p[0] * 55, 0, -15 + p[1] * 30)
				frontRoofShelfGeometry.merge(geometry)
				}
				frontRoofShelfGeometry = new THREE.BufferGeometry().fromGeometry(frontRoofShelfGeometry)
				var frontRoofShelf = utils.makeMesh('phong', frontRoofShelfGeometry, 0xffffff)
				frontRoofShelf.position.set(-70, 115, 5)
				hospital.add(frontRoofShelf)

				var frontPlatGeometry = new THREE.BoxBufferGeometry(150, 3, 90)
				var fronPlat = utils.makeMesh('lambert', frontPlatGeometry, 0x0792a5)
				fronPlat.position.set(-3, 18, 25)
				hospital.add(fronPlat)

				var frontPlatVerticalGeometry = new THREE.BoxBufferGeometry(150, 15, 3)
				var frontPlatVertical = utils.makeMesh('phong', frontPlatVerticalGeometry, 0x0792a5)
				frontPlatVertical.receiveShadow = false
				frontPlatVertical.position.set(-3, 24, 68.5)
				hospital.add(frontPlatVertical)

				var frontPlatVerticalWhiteGeometry = new THREE.BoxBufferGeometry(150, 3, 3)
				var frontPlatVerticalWhite = utils.makeMesh('phong', frontPlatVerticalWhiteGeometry, 0xffffff)
				frontPlatVerticalWhite.position.set(-3, 33, 68.5)
				hospital.add(frontPlatVerticalWhite)

				var frontPlatPillarGeometry = new THREE.CylinderGeometry(2, 2, 15, 32)
				var frontPlatPillar = utils.makeMesh('lambert', frontPlatPillarGeometry, 0xffffff)
				frontPlatPillar.position.set(-60, 10, 55)
				hospital.add(frontPlatPillar)

				var frontPlatPillar2 = frontPlatPillar.clone()
				frontPlatPillar2.position.set(55, 10, 55)
				hospital.add(frontPlatPillar2)

				var frontBorderVerticles = new THREE.Object3D()
				var frontBorderVerticleGeometry = new THREE.BoxBufferGeometry(4, 106, 4)
				var frontBorderVerticleMesh = utils.makeMesh('phong', frontBorderVerticleGeometry, 0xffffff)
				var frontBorderVerticle1 = frontBorderVerticleMesh.clone()
				frontBorderVerticle1.position.set(-80, 52, 30)
				frontBorderVerticles.add(frontBorderVerticle1)
				var frontBorderVerticle2 = frontBorderVerticleMesh.clone()
				frontBorderVerticle2.position.set(-80, 52, -20)
				frontBorderVerticles.add(frontBorderVerticle2)
				var frontBorderVerticle3 = frontBorderVerticleMesh.clone()
				frontBorderVerticle3.position.set(50, 52, -18)
				frontBorderVerticles.add(frontBorderVerticle3)
				hospital.add(frontBorderVerticles)

				var frontRoofCoords = [
				[-82, -32],
				[20, -32],
				[52, 0],
				[52, 22],
				[-82, 22],
				[-82, -32]
				]
				var frontRoofHolePath = [
				[-78, -28],
				[20, -28],
				[48, 0],
				[48, 18],
				[-78, 18],
				[-78, -28]
				]
				var frontRoofShape = utils.makeShape(frontRoofCoords, frontRoofHolePath)
				var frontRoofGeometry = utils.makeExtrudeGeometry(frontRoofShape, 8)
				var frontRoof = utils.makeMesh('phong', frontRoofGeometry, 0xffffff)
				frontRoof.position.y = 100
				hospital.add(frontRoof)

				var backMainCoords = [
				[-80, 20],
				[-80, 60],
				[80, 60],
				[80, 20],
				[-80, 20]
				]
				var backMainHolePath = [
				[-78, 22],
				[78, 22],
				[78, 58],
				[-78, 58],
				[-78, 22]
				]
				var backMainShape = utils.makeShape(backMainCoords, backMainHolePath)

				var backMainGeometry = utils.makeExtrudeGeometry(backMainShape, 90)
				var backMain = utils.makeMesh('lambert', backMainGeometry, 0xf2e21b)
				hospital.add(backMain)

				var backMiddleCoords = [
				[0, 0],
				[36, 0],
				[36, 70],
				[0, 70],
				[0, 0]
				]
				var backMiddleHolePath = [
				[2, 2],
				[34, 2],
				[34, 68],
				[2, 68],
				[2, 2]
				]
				var backMiddleShape = utils.makeShape(backMiddleCoords, backMiddleHolePath)
				var backMiddkeGeometry = utils.makeExtrudeGeometry(backMiddleShape, 165)
				var backMiddle = utils.makeMesh('lambert', backMiddkeGeometry, 0xffffff)

				backMiddle.rotation.x = -0.5 * Math.PI
				backMiddle.rotation.z = -0.5 * Math.PI
				backMiddle.position.y = 86
				backMiddle.position.z = -58
				backMiddle.position.x = -78
				hospital.add(backMiddle)

				var backMiddleWindowGeometry = new THREE.PlaneGeometry(32, 66, 1, 1)
				var backMiddleWindowMaterial = new THREE.MeshPhongMaterial({ map: textures.window() })
				backMiddleWindowMaterial.map.repeat.set(2, 6)

				var backMiddleWindow = new THREE.Mesh(backMiddleWindowGeometry, backMiddleWindowMaterial)
				backMiddleWindow.position.set(83, 51, -40)
				backMiddleWindow.rotation.y = 0.5 * Math.PI
				hospital.add(backMiddleWindow)

				var windowBackOrigin = createWindow()
				windowBackOrigin.scale.set(0.6, 0.6, 1)
				windowBackOrigin.rotation.y = Math.PI
				windowBackOrigin.position.set(65, 75, -61)
				for (var i = 0; i < 7; i++) {
				for (var j = 0; j < 4; j++) {
					var windowObj = windowBackOrigin.clone()
					windowObj.position.x -= i * 22
					windowObj.position.y -= j * 20
					hospital.add(windowObj)
				}
				}

				return hospital	
			}

			function createWindow() {
				var windowObj = new THREE.Object3D()
				var glassGeometry = new THREE.PlaneGeometry(20, 20)
				var glass = utils.makeMesh('phong', glassGeometry, 0x6a5e74)
				windowObj.add(glass)

				var windowBorderGeometry = new THREE.BoxBufferGeometry(22, 2, 2)
				var windowBorder = utils.makeMesh('phong', windowBorderGeometry, 0xffffff)

				var windowBorderTop = windowBorder.clone()
				windowBorderTop.position.y = 10
				windowObj.add(windowBorderTop)

				var windowBorderBottom = windowBorder.clone()
				windowBorderBottom.position.y = -10
				windowObj.add(windowBorderBottom)

				var windowBorderLeft = windowBorder.clone()
				windowBorderLeft.rotation.z = 0.5 * Math.PI
				windowBorderLeft.position.x = -10
				windowObj.add(windowBorderLeft)

				var windowBorderRight = windowBorderLeft.clone()
				windowBorderRight.position.x = 10
				windowObj.add(windowBorderRight)

				return windowObj
			}



		</script>
	</body>
</html>