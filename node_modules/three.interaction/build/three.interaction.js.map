{"version":3,"file":"three.interaction.js","sources":["../src/utils/Utils.js","../src/patch/EventDispatcher.js","../src/patch/Object3D.js","../src/interaction/InteractionData.js","../src/interaction/InteractionEvent.js","../src/interaction/InteractionTrackingData.js","../src/interaction/InteractionManager.js","../src/utils/Raf.js","../src/utils/Ticker.js","../src/interaction/Interaction.js"],"sourcesContent":["/**\n * get variable type\n * @param {*} val a variable which you want to get the type\n * @return {String} variable-type\n */\nfunction _rt(val) {\n  return Object.prototype.toString.call(val);\n}\n\n/**\n * Utils tool box\n *\n * @namespace Utils\n */\nexport const Utils = {\n  /**\n   * determine whether it is a `Function`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isFunction: (function() {\n    const ks = _rt(function() {});\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n\n\n  /**\n   * determine whether it is a `undefined`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isUndefined(variable) {\n    return typeof variable === 'undefined';\n  },\n};\n","import { EventDispatcher, Object3D } from 'three';\nimport { Utils } from '../utils/Utils.js';\n\n/**\n * proxy `addEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nEventDispatcher.prototype.on = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  if (this instanceof Object3D) this.interactive = true;\n  this.addEventListener(type, fn);\n  return this;\n};\n\n/**\n * proxy `removeEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback, which you had bind before\n * @return {this} this\n */\nEventDispatcher.prototype.off = function(type, fn) {\n  this.removeEventListener(type, fn);\n  return this;\n};\n\n/**\n * binding a once event, just emit once time\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nEventDispatcher.prototype.once = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  const cb = (ev) => {\n    fn(ev);\n    this.off(type, cb);\n  };\n  this.on(type, cb);\n  return this;\n};\n\n/**\n * emit a event\n *\n * @param {String} type event type, evnet name\n * @return {this} this\n */\nEventDispatcher.prototype.emit = function(type, ...argument) {\n  if (this._listeners === undefined || Utils.isUndefined(this._listeners[type])) return;\n  const cbs = this._listeners[type] || [];\n  const cache = cbs.slice(0);\n\n  for (let i = 0; i < cache.length; i++) {\n    cache[i].apply(this, argument);\n  }\n  return this;\n};\n\n","import { Object3D } from 'three';\n\n/**\n * whether displayObject is interactively\n */\nObject3D.prototype.interactive = false;\n\n/**\n * whether displayObject's children is interactively\n */\nObject3D.prototype.interactiveChildren = true;\n\n/**\n * whether displayObject had touchstart\n * @private\n */\nObject3D.prototype.started = false;\n\n/**\n * tracked event cache, like: touchend、mouseout、pointerout which decided by primary-event\n */\nObject.defineProperty(Object3D.prototype, 'trackedPointers', {\n  get() {\n    if (!this._trackedPointers) this._trackedPointers = {};\n    return this._trackedPointers;\n  },\n});\n\n/**\n * dispatch a raycast\n *\n * @param {Raycaster} raycaster Raycaster object, get from THREE.Raycaster\n * @return {Object|Boolean} had pass hit-test\n */\nObject3D.prototype.raycastTest = function(raycaster) {\n  const result = [];\n  this.raycast(raycaster, result);\n\n  if (result.length > 0) {\n    return result[0];\n  }\n\n  return false;\n};\n","import { Vector2 } from 'three';\n\n/**\n * Holds all information related to an Interaction event\n *\n * @class\n */\nclass InteractionData {\n  /**\n   * InteractionData constructor\n   */\n  constructor() {\n    /**\n     * This point stores the global coords of where the touch/mouse event happened\n     *\n     * @member {Vector2}\n     */\n    this.global = new Vector2();\n\n    /**\n     * The target DisplayObject that was interacted with\n     *\n     * @member {Object3D}\n     */\n    this.target = null;\n\n    /**\n     * When passed to an event handler, this will be the original DOM Event that was captured\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent\n     * @member {MouseEvent|TouchEvent|PointerEvent}\n     */\n    this.originalEvent = null;\n\n    /**\n     * Unique identifier for this interaction\n     *\n     * @member {number}\n     */\n    this.identifier = null;\n\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     * @type {Boolean}\n     */\n    this.isPrimary = false;\n\n    /**\n     * Indicates which button was pressed on the mouse or pointer device to trigger the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n     * @type {number}\n     */\n    this.button = 0;\n\n    /**\n     * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n     * @type {number}\n     */\n    this.buttons = 0;\n\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     * @type {number}\n     */\n    this.tiltX = 0;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     * @type {number}\n     */\n    this.tiltY = 0;\n\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     * @type {string}\n     */\n    this.pointerType = null;\n\n    /**\n     * Pressure applied by the pointing device during the event. A Touch's force property\n     * will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     * @type {number}\n     */\n    this.pressure = 0;\n\n    /**\n     * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n     * @type {number}\n     */\n    this.rotationAngle = 0;\n\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n    this.twist = 0;\n\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n    this.tangentialPressure = 0;\n  }\n\n  /**\n   * The unique identifier of the pointer. It will be the same as `identifier`.\n   * @readonly\n   * @member {number}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n   */\n  get pointerId() {\n    return this.identifier;\n  }\n\n  /**\n   * Copies properties from normalized event data.\n   *\n   * @param {Touch|MouseEvent|PointerEvent} event The normalized event data\n   * @private\n   */\n  _copyEvent(event) {\n    // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n    // it with \"false\" on later events when our shim for it on touch events might not be\n    // accurate\n    if (event.isPrimary) {\n      this.isPrimary = true;\n    }\n    this.button = event.button;\n    this.buttons = event.buttons;\n    this.width = event.width;\n    this.height = event.height;\n    this.tiltX = event.tiltX;\n    this.tiltY = event.tiltY;\n    this.pointerType = event.pointerType;\n    this.pressure = event.pressure;\n    this.rotationAngle = event.rotationAngle;\n    this.twist = event.twist || 0;\n    this.tangentialPressure = event.tangentialPressure || 0;\n  }\n\n  /**\n   * Resets the data for pooling.\n   *\n   * @private\n   */\n  _reset() {\n    // isPrimary is the only property that we really need to reset - everything else is\n    // guaranteed to be overwritten\n    this.isPrimary = false;\n  }\n}\n\nexport default InteractionData;\n","/**\n * Event class that mimics native DOM events.\n *\n * @class\n */\nclass InteractionEvent {\n  /**\n   * InteractionEvent constructor\n   */\n  constructor() {\n    /**\n     * Whether this event will continue propagating in the tree\n     *\n     * @member {boolean}\n     */\n    this.stopped = false;\n\n    /**\n     * The object which caused this event to be dispatched.\n     *\n     * @member {Object3D}\n     */\n    this.target = null;\n\n    /**\n     * The object whose event listener’s callback is currently being invoked.\n     *\n     * @member {Object3D}\n     */\n    this.currentTarget = null;\n\n    /**\n     * Type of the event\n     *\n     * @member {string}\n     */\n    this.type = null;\n\n    /**\n     * InteractionData related to this event\n     *\n     * @member {InteractionData}\n     */\n    this.data = null;\n\n    /**\n     * ray caster detial from 3d-mesh\n     *\n     * @member {Intersect}\n     */\n    this.intersect = null;\n  }\n\n  /**\n   * Prevents event from reaching any objects other than the current object.\n   *\n   */\n  stopPropagation() {\n    this.stopped = true;\n  }\n\n  /**\n   * Resets the event.\n   *\n   * @private\n   */\n  _reset() {\n    this.stopped = false;\n    this.currentTarget = null;\n    this.target = null;\n    this.intersect = null;\n  }\n}\n\nexport default InteractionEvent;\n","/**\n * DisplayObjects with the `trackedPointers` property use this class to track interactions\n *\n * @class\n * @private\n */\nexport default class InteractionTrackingData {\n  /**\n   * @param {number} pointerId - Unique pointer id of the event\n   */\n  constructor(pointerId) {\n    this._pointerId = pointerId;\n    this._flags = InteractionTrackingData.FLAGS.NONE;\n  }\n\n  /**\n   *\n   * @private\n   * @param {number} flag - The interaction flag to set\n   * @param {boolean} yn - Should the flag be set or unset\n   */\n  _doSet(flag, yn) {\n    if (yn) {\n      this._flags = this._flags | flag;\n    } else {\n      this._flags = this._flags & (~flag);\n    }\n  }\n\n  /**\n   * Unique pointer id of the event\n   *\n   * @readonly\n   * @member {number}\n   */\n  get pointerId() {\n    return this._pointerId;\n  }\n\n  /**\n   * State of the tracking data, expressed as bit flags\n   *\n   * @member {number}\n   */\n  get flags() {\n    return this._flags;\n  }\n\n  /**\n   * Set the flags for the tracking data\n   *\n   * @param {number} flags - Flags to set\n   */\n  set flags(flags) {\n    this._flags = flags;\n  }\n\n  /**\n   * Is the tracked event inactive (not over or down)?\n   *\n   * @member {number}\n   */\n  get none() {\n    return this._flags === this.constructor.FLAGS.NONE;\n  }\n\n  /**\n   * Is the tracked event over the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get over() {\n    return (this._flags & this.constructor.FLAGS.OVER) !== 0;\n  }\n\n  /**\n   * Set the over flag\n   *\n   * @param {boolean} yn - Is the event over?\n   */\n  set over(yn) {\n    this._doSet(this.constructor.FLAGS.OVER, yn);\n  }\n\n  /**\n   * Did the right mouse button come down in the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get rightDown() {\n    return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;\n  }\n\n  /**\n   * Set the right down flag\n   *\n   * @param {boolean} yn - Is the right mouse button down?\n   */\n  set rightDown(yn) {\n    this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);\n  }\n\n  /**\n   * Did the left mouse button come down in the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get leftDown() {\n    return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;\n  }\n\n  /**\n   * Set the left down flag\n   *\n   * @param {boolean} yn - Is the left mouse button down?\n   */\n  set leftDown(yn) {\n    this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);\n  }\n}\n\nInteractionTrackingData.FLAGS = Object.freeze({\n  NONE: 0,\n  OVER: 1 << 0,\n  LEFT_DOWN: 1 << 1,\n  RIGHT_DOWN: 1 << 2,\n});\n","import '../patch/EventDispatcher';\nimport '../patch/Object3D';\n\nimport { EventDispatcher, Raycaster } from 'three';\nimport InteractionData from './InteractionData';\nimport InteractionEvent from './InteractionEvent';\nimport InteractionTrackingData from './InteractionTrackingData';\n\nconst MOUSE_POINTER_ID = 'MOUSE';\n\n// helpers for hitTest() - only used inside hitTest()\nconst hitTestEvent = {\n  target: null,\n  data: {\n    global: null,\n  },\n};\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\nclass InteractionManager extends EventDispatcher {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, scene, camera, options) {\n    super();\n\n    options = options || {};\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n    this.scene = scene;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n    this.camera = camera;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoPreventDefault = options.autoPreventDefault || false;\n\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n    this.interactionFrequency = options.interactionFrequency || 10;\n\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n    this.mouse = new InteractionData();\n    this.mouse.identifier = MOUSE_POINTER_ID;\n\n    // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n    this.mouse.global.set(-999999);\n\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n    this.activeInteractionData = {};\n    this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n    this.interactionDataPool = [];\n\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n    this.eventData = new InteractionEvent();\n\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n    this.interactionDOMElement = null;\n\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.moveWhenInside = true;\n\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.eventsAdded = false;\n\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.mouseOverRenderer = false;\n\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsTouchEvents = 'ontouchstart' in window;\n\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsPointerEvents = !!window.PointerEvent;\n\n    // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onClick = this.onClick.bind(this);\n    this.processClick = this.processClick.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.processPointerUp = this.processPointerUp.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerCancel = this.onPointerCancel.bind(this);\n    this.processPointerCancel = this.processPointerCancel.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.processPointerDown = this.processPointerDown.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.processPointerMove = this.processPointerMove.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOut = this.onPointerOut.bind(this);\n    this.processPointerOverOut = this.processPointerOverOut.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOver = this.onPointerOver.bind(this);\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n    this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer',\n    };\n\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n    this.currentCursorMode = null;\n\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n    this.cursor = null;\n\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n    this.raycaster = new Raycaster();\n\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n    this._deltaTime = 0;\n\n    this.setTargetElement(this.renderer.domElement);\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionManager#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionManager#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionManager#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionManager#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionManager#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionManager#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionManager#event:mousedown}.\n     *\n     * @event InteractionManager#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionManager#event:rightdown}.\n     *\n     * @event InteractionManager#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionManager#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionManager#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionManager#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionManager#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionManager#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionManager#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionManager#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionManager#event:pointerdown}.\n     *\n     * @event InteractionManager#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionManager#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionManager#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionManager#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionManager#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionManager#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionManager#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionManager#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionManager#event:touchstart}.\n     *\n     * @event InteractionManager#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionManager#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n  }\n\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {Point} globalPoint - A point to hit test with, in global space.\n   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {Object3D} The hit display object, if any.\n   */\n  hitTest(globalPoint, root) {\n    // clear the target for our hit test\n    hitTestEvent.target = null;\n    // assign the global point\n    hitTestEvent.data.global = globalPoint;\n    // ensure safety of the root\n    if (!root) {\n      root = this.scene;\n    }\n    // run the hit test\n    this.processInteractive(hitTestEvent, root, null, true);\n    // return our found object - it'll be null if we didn't hit anything\n\n    return hitTestEvent.target;\n  }\n\n  /**\n   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n   * another DOM element to receive those events.\n   *\n   * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n   */\n  setTargetElement(element) {\n    this.removeEvents();\n\n    this.interactionDOMElement = element;\n\n    this.addEvents();\n  }\n\n  /**\n   * Registers all the DOM events\n   *\n   * @private\n   */\n  addEvents() {\n    if (!this.interactionDOMElement || this.eventsAdded) {\n      return;\n    }\n\n    this.emit('addevents');\n\n    this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n      this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = 'none';\n    }\n\n    /**\n     * These events are added first, so that if pointer events are normalised, they are fired\n     * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n     */\n    if (this.supportsPointerEvents) {\n      window.document.addEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);\n      // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n      // we already handle those, so for the purposes of what we do in onPointerOut, we only\n      // care about the pointerleave event\n      this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n      window.addEventListener('pointercancel', this.onPointerCancel, true);\n      window.addEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.addEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n      window.addEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    // always look directly for touch events so that we can provide original data\n    // In a future version we should change this to being just a fallback and rely solely on\n    // PointerEvents whenever available\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.eventsAdded = true;\n  }\n\n  /**\n   * Removes all the DOM events that were previously registered\n   *\n   * @private\n   */\n  removeEvents() {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    this.emit('removeevents');\n\n    this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = '';\n      this.interactionDOMElement.style['-ms-touch-action'] = '';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = '';\n    }\n\n    if (this.supportsPointerEvents) {\n      window.document.removeEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n      window.removeEventListener('pointercancel', this.onPointerCancel, true);\n      window.removeEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.removeEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n      window.removeEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.interactionDOMElement = null;\n\n    this.eventsAdded = false;\n  }\n\n  /**\n   * Updates the state of interactive objects.\n   * Invoked by a throttled ticker.\n   *\n   * @param {number} deltaTime - time delta since last tick\n   */\n  update({ snippet }) {\n    this._deltaTime += snippet;\n\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n\n    this._deltaTime = 0;\n\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    // if the user move the mouse this check has already been done using the mouse move!\n    if (this.didMove) {\n      this.didMove = false;\n\n      return;\n    }\n\n    this.cursor = null;\n\n    // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n    // but there was a scenario of a display object moving under a static mouse cursor.\n    // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n    for (const k in this.activeInteractionData) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        const interactionData = this.activeInteractionData[k];\n\n        if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n          const interactionEvent = this.configureInteractionEventForDOMEvent(\n            this.eventData,\n            interactionData.originalEvent,\n            interactionData\n          );\n\n          this.processInteractive(\n            interactionEvent,\n            this.scene,\n            this.processPointerOverOut,\n            true\n          );\n        }\n      }\n    }\n\n    this.setCursorMode(this.cursor);\n\n    // TODO\n  }\n\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   *\n   * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  setCursorMode(mode) {\n    mode = mode || 'default';\n    // if the mode didn't actually change, bail early\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n    this.currentCursorMode = mode;\n    const style = this.cursorStyles[mode];\n\n    // only do things if there is a cursor style for it\n    if (style) {\n      switch (typeof style) {\n        case 'string':\n          // string styles are handled as cursor CSS\n          this.interactionDOMElement.style.cursor = style;\n          break;\n        case 'function':\n          // functions are just called, and passed the cursor mode\n          style(mode);\n          break;\n        case 'object':\n          // if it is an object, assume that it is a dictionary of CSS styles,\n          // apply it to the interactionDOMElement\n          Object.assign(this.interactionDOMElement.style, style);\n          break;\n        default:\n          break;\n      }\n    } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n      // for the mode, then assume that the dev wants it to be CSS for the cursor.\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  }\n\n  /**\n   * Dispatches an event on the display object that was interacted with\n   *\n   * @param {Object3D} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n  triggerEvent(displayObject, eventString, eventData) {\n    if (!eventData.stopped) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n\n      displayObject.emit(eventString, eventData);\n\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  }\n\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   *\n   * @param  {Vector2} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n  mapPositionToPoint(point, x, y) {\n    let rect;\n\n    // IE 11 fix\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n\n    point.x = ((x - rect.left) / rect.width) * 2 - 1;\n    point.y = -((y - rect.top) / rect.height) * 2 + 1;\n  }\n\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param {Object3D} displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param {Function} [func] - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n   * @param {boolean} [interactive] - Whether the displayObject is interactive\n   * @return {boolean} returns true if the displayObject hit the point\n   */\n  processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n    if (!displayObject || !displayObject.visible) {\n      return false;\n    }\n\n    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n    //\n    // This function will now loop through all objects and then only hit test the objects it HAS\n    // to, not all of them. MUCH faster..\n    // An object will be hit test if the following is true:\n    //\n    // 1: It is interactive.\n    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n    //\n    // As another little optimisation once an interactive object has been hit we can carry on\n    // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n    // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n    interactive = displayObject.interactive || interactive;\n\n    let hit = false;\n    let interactiveParent = interactive;\n\n    if (displayObject.interactiveChildren && displayObject.children) {\n      const children = displayObject.children;\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n\n        // time to get recursive.. if this function will return if something is hit..\n        const childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n        if (childHit) {\n          // its a good idea to check if a child has lost its parent.\n          // this means it has been removed whilst looping so its best\n          if (!child.parent) {\n            continue;\n          }\n\n          // we no longer need to hit test any more objects in this container as we we\n          // now know the parent has been hit\n          interactiveParent = false;\n\n          // If the child is interactive , that means that the object hit was actually\n          // interactive and not just the child of an interactive object.\n          // This means we no longer need to hit test anything else. We still need to run\n          // through all objects, but we don't need to perform any hit tests.\n\n          if (childHit) {\n            if (interactionEvent.target) {\n              hitTest = false;\n            }\n            hit = true;\n          }\n        }\n      }\n    }\n\n    // no point running this if the item is not interactive or does not have an interactive parent.\n    if (interactive) {\n      // if we are hit testing (as in we have no hit any objects yet)\n      // We also don't need to worry about hit testing if once of the displayObjects children\n      // has already been hit - but only if it was interactive, otherwise we need to keep\n      // looking for an interactive child, just in case we hit one\n      if (hitTest && !interactionEvent.target) {\n        const intersect = displayObject.raycastTest(this.raycaster);\n        if (intersect) {\n          interactionEvent.intersect = intersect;\n          hit = true;\n        }\n      }\n\n      if (displayObject.interactive) {\n        if (hit && !interactionEvent.target) {\n          interactionEvent.data.target = interactionEvent.target = displayObject;\n        }\n\n        if (func) {\n          func(interactionEvent, displayObject, !!hit);\n        }\n      }\n    }\n\n    return hit;\n  }\n\n\n  /**\n   * Is called when the click is pressed down on the renderer element\n   *\n   * @private\n   * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n   */\n  onClick(originalEvent) {\n    if (originalEvent.type !== 'click') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(events[0]);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n\n    interactionEvent.data.originalEvent = originalEvent;\n\n    this.processInteractive(interactionEvent, this.scene, this.processClick, true);\n\n    this.emit('click', interactionEvent);\n  }\n\n  /**\n   * Processes the result of the click check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processClick(interactionEvent, displayObject, hit) {\n    if (hit) {\n      this.triggerEvent(displayObject, 'click', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer button is pressed down on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n   */\n  onPointerDown(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    /**\n     * No need to prevent default on natural pointer events, as there are no side effects\n     * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n     * so still need to be prevented.\n     */\n\n    // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      this.processInteractive(interactionEvent, this.scene, this.processPointerDown, true);\n\n      this.emit('pointerdown', interactionEvent);\n      if (event.pointerType === 'touch') {\n        this.emit('touchstart', interactionEvent);\n      } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n      }\n    }\n  }\n\n  /**\n   * Processes the result of the pointer down check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerDown(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n    const id = interactionEvent.data.identifier;\n\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n      this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        displayObject.started = true;\n        this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n      } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n        const isRightButton = data.button === 2;\n\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n\n        this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n   * @param {boolean} cancelled - true if the pointer is cancelled\n   * @param {Function} func - Function passed to {@link processInteractive}\n   */\n  onPointerComplete(originalEvent, cancelled, func) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    const eventLen = events.length;\n\n    // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n    // in all cases (unless it was a pointercancel)\n    const eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      // perform hit testing for events targeting our canvas or cancel events\n      this.processInteractive(interactionEvent, this.scene, func, cancelled || !eventAppend);\n\n      this.emit(cancelled ? 'pointercancel' : `pointerup${eventAppend}`, interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? `rightup${eventAppend}` : `mouseup${eventAppend}`, interactionEvent);\n      } else if (event.pointerType === 'touch') {\n        this.emit(cancelled ? 'touchcancel' : `touchend${eventAppend}`, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is cancelled\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerCancel(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  }\n\n  /**\n   * Processes the result of the pointer cancel check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   */\n  processPointerCancel(interactionEvent, displayObject) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    if (displayObject.trackedPointers[id] !== undefined) {\n      delete displayObject.trackedPointers[id];\n      this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerUp(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, false, this.processPointerUp);\n  }\n\n  /**\n   * Processes the result of the pointer up check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerUp(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const trackingData = displayObject.trackedPointers[id];\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    // Mouse only\n    if (isMouse) {\n      const isRightButton = data.button === 2;\n\n      const flags = InteractionTrackingData.FLAGS;\n\n      const test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n\n      const isDown = trackingData !== undefined && (trackingData.flags & test);\n\n      if (hit) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n        if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n        }\n      } else if (isDown) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n      }\n      // update the down state of the tracking data\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    }\n\n    // Pointers and Touches, and Mouse\n    if (isTouch && displayObject.started) {\n      displayObject.started = false;\n      this.triggerEvent(displayObject, 'touchend', interactionEvent);\n    }\n    if (hit) {\n      this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n      if (trackingData) {\n        this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n        if (isTouch) {\n          this.triggerEvent(displayObject, 'tap', interactionEvent);\n          // touches are no longer over (if they ever were) when we get the touchend\n          // so we should ensure that we don't keep pretending that they are\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n      if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n    }\n    // Only remove the tracking data if there is no over/down state still associated with it\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  }\n\n  /**\n   * Is called when the pointer moves across the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n   */\n  onPointerMove(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (events[0].pointerType === 'mouse') {\n      this.didMove = true;\n\n      this.cursor = null;\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      const interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n\n      this.processInteractive(\n        interactionEvent,\n        this.scene,\n        this.processPointerMove,\n        interactive\n      );\n      this.emit('pointermove', interactionEvent);\n      if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n    }\n\n    if (events[0].pointerType === 'mouse') {\n      this.setCursorMode(this.cursor);\n\n      // TODO BUG for parents interactive object (border order issue)\n    }\n  }\n\n  /**\n   * Processes the result of the pointer move check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerMove(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n\n    if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n    if (!this.moveWhenInside || hit) {\n      this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n      if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved out of the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n   */\n  onPointerOut(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOut, so events will always be length 1\n    const event = events[0];\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, false);\n\n    this.emit('pointerout', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseout', interactionEvent);\n    } else {\n      // we can get touchleave events after touchend, so we want to make sure we don't\n      // introduce memory leaks\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  }\n\n  /**\n   * Processes the result of the pointer over/out check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerOverOut(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    let trackingData = displayObject.trackedPointers[id];\n\n    // if we just moused over the display object, then we need to track that state\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n\n    if (trackingData === undefined) return;\n\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n        }\n      }\n\n      // only change the cursor if it has not already been changed (by something deeper in the\n      // display tree)\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.triggerEvent(displayObject, 'pointerout', this.eventData);\n      if (isMouse) {\n        this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n      }\n      // if there is no mouse down information for the pointer, then it is safe to delete\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved into the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n   */\n  onPointerOver(originalEvent) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOver, so events will always be length 1\n    const event = events[0];\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = true;\n    }\n\n    this.emit('pointerover', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseover', interactionEvent);\n    }\n  }\n\n  /**\n   * Get InteractionData for a given pointerId. Store that data as well\n   *\n   * @private\n   * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n   * @return {InteractionData} - Interaction data for the given pointer identifier\n   */\n  getInteractionDataForPointerId(event) {\n    const pointerId = event.pointerId;\n\n    let interactionData;\n\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    }\n    // copy properties from the event, so that we can make sure that touch/pointer specific\n    // data is available\n    interactionData._copyEvent(event);\n\n    return interactionData;\n  }\n\n  /**\n   * Return unused InteractionData to the pool, for a given pointerId\n   *\n   * @private\n   * @param {number} pointerId - Identifier from a pointer event\n   */\n  releaseInteractionDataForPointerId(pointerId) {\n    const interactionData = this.activeInteractionData[pointerId];\n\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData._reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  }\n\n  /**\n   * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The event to be configured\n   * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n   * @param {InteractionData} interactionData - The InteractionData that will be paired\n   *        with the InteractionEvent\n   * @return {InteractionEvent} the interaction event that was passed in\n   */\n  configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n\n    this.raycaster.setFromCamera(interactionData.global, this.camera);\n\n    // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n    if (pointerEvent.pointerType === 'touch') {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent._reset();\n\n    return interactionEvent;\n  }\n\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   *\n   * @private\n   * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n   * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n\n        if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n        if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n        if (typeof touch.isPrimary === 'undefined') {\n          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n        }\n        if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n        if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n        if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n        if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n        if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n        touch.twist = 0;\n        touch.tangentialPressure = 0;\n        // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n        // support, and the fill ins are not quite the same\n        // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n        // left is not 0,0 on the page\n        if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n        // mark the touch as normalized, just so that we know we did it\n        touch.isNormalized = true;\n\n        normalizedEvents.push(touch);\n      }\n    } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n      if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n      if (typeof event.width === 'undefined') event.width = 1;\n      if (typeof event.height === 'undefined') event.height = 1;\n      if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n      if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n      if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n      if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n      if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n      event.twist = 0;\n      event.tangentialPressure = 0;\n\n      // mark the mouse event as normalized, just so that we know we did it\n      event.isNormalized = true;\n\n      normalizedEvents.push(event);\n    } else {\n      normalizedEvents.push(event);\n    }\n\n    return normalizedEvents;\n  }\n\n  /**\n   * Destroys the interaction manager\n   *\n   */\n  destroy() {\n    this.removeEvents();\n\n    this.removeAllListeners();\n\n    this.renderer = null;\n\n    this.mouse = null;\n\n    this.eventData = null;\n\n    this.interactionDOMElement = null;\n\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n\n    this.onPointerOver = null;\n\n    this._tempPoint = null;\n  }\n}\n\nexport default InteractionManager;\n","(function() {\n  let lastTime = 0;\n  let vendors = ['ms', 'moz', 'webkit', 'o'];\n  for (let x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\n            window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = function(callback) {\n      let currTime = new Date().getTime();\n      let timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      let id = window.setTimeout(function() {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n  }\n\n  if (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function(id) {\n      clearTimeout(id);\n    };\n  }\n\n  window.RAF = window.requestAnimationFrame;\n  window.CAF = window.cancelAnimationFrame;\n})();\n","import './Raf';\nimport { EventDispatcher } from 'three';\n\n/**\n * @extends EventDispatcher\n */\nclass Ticker extends EventDispatcher {\n  /**\n   *\n   */\n  constructor() {\n    super();\n    this.timer = null;\n    this.started = false;\n\n    /**\n     * pre-time cache\n     *\n     * @member {Number}\n     * @private\n     */\n    this.pt = 0;\n\n    /**\n     * how long the time through, at this tick\n     *\n     * @member {Number}\n     * @private\n     */\n    this.snippet = 0;\n\n    this.start();\n  }\n\n  /**\n   * start tick loop\n   */\n  start() {\n    if (this.started) return;\n    const loop = () => {\n      this.timeline();\n      this.emit('tick', { snippet: this.snippet });\n      this.timer = RAF(loop);\n    };\n    loop();\n  }\n\n  /**\n   * stop tick loop\n   */\n  stop() {\n    CAF(this.timer);\n    this.started = false;\n  }\n\n  /**\n   * get timeline snippet\n   *\n   * @private\n   */\n  timeline() {\n    this.snippet = Date.now() - this.pt;\n    if (this.pt === 0 || this.snippet > 200) {\n      this.pt = Date.now();\n      this.snippet = Date.now() - this.pt;\n    }\n\n    this.pt += this.snippet;\n  }\n}\n\nexport default Ticker;\n","import Ticker from '../utils/Ticker';\nimport InteractionManager from './InteractionManager';\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @example\n * import { Scene, PerspectiveCamera, WebGLRenderer, Mesh, BoxGeometry, MeshBasicMaterial } from 'three';\n * import { Interaction } from 'three.interaction';\n * const renderer = new WebGLRenderer({ canvas: canvasElement });\n * const scene = new Scene();\n * const camera = new PerspectiveCamera(60, width / height, 0.1, 100);\n *\n * const interaction = new Interaction(renderer, scene, camera);\n * // then you can bind every interaction event with any mesh which you had `add` into `scene` before\n * const cube = new Mesh(\n *   new BoxGeometry(1, 1, 1),\n *   new MeshBasicMaterial({ color: 0xffffff }),\n * );\n * scene.add(cube);\n * cube.on('touchstart', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('mousedown', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('pointerdown', ev => {\n *   console.log(ev);\n * });\n * // and so on ...\n *\n * // you can also listen on parent-node or any display-tree node,\n * // source event will bubble up along with display-tree.\n * // you can stop the bubble-up by invoke ev.stopPropagation function.\n * scene.on('touchstart', ev => {\n *   console.log(ev);\n * })\n *\n * @class\n * @extends InteractionManager\n */\nclass Interaction extends InteractionManager {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=false] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, scene, camera, options) {\n    options = Object.assign({ autoAttach: false }, options);\n    super(renderer, scene, camera, options);\n\n    /**\n     * a ticker\n     *\n     * @private\n     * @member {Ticker}\n     */\n    this.ticker = new Ticker();\n\n    /**\n     * update for some over event\n     *\n     * @private\n     */\n    this.update = this.update.bind(this);\n\n    this.on('addevents', () => {\n      this.ticker.on('tick', this.update);\n    });\n\n    this.on('removeevents', () => {\n      this.ticker.off('tick', this.update);\n    });\n\n    this.setTargetElement(this.renderer.domElement);\n  }\n}\n\nexport default Interaction;\n"],"names":["_rt","val","Object","prototype","toString","call","Utils","ks","variable","EventDispatcher","on","type","fn","isFunction","Object3D","interactive","addEventListener","off","removeEventListener","once","cb","ev","emit","_listeners","undefined","isUndefined","cbs","cache","slice","argument","i","length","apply","interactiveChildren","started","defineProperty","_trackedPointers","raycastTest","raycaster","result","raycast","InteractionData","global","Vector2","target","originalEvent","identifier","isPrimary","button","buttons","width","height","tiltX","tiltY","pointerType","pressure","rotationAngle","twist","tangentialPressure","event","InteractionEvent","stopped","currentTarget","data","intersect","InteractionTrackingData","pointerId","_pointerId","_flags","FLAGS","NONE","flag","yn","flags","constructor","OVER","_doSet","RIGHT_DOWN","LEFT_DOWN","freeze","MOUSE_POINTER_ID","hitTestEvent","InteractionManager","renderer","scene","camera","options","autoPreventDefault","interactionFrequency","mouse","set","activeInteractionData","interactionDataPool","eventData","interactionDOMElement","moveWhenInside","eventsAdded","mouseOverRenderer","supportsTouchEvents","window","supportsPointerEvents","PointerEvent","onClick","bind","processClick","onPointerUp","processPointerUp","onPointerCancel","processPointerCancel","onPointerDown","processPointerDown","onPointerMove","processPointerMove","onPointerOut","processPointerOverOut","onPointerOver","cursorStyles","currentCursorMode","cursor","Raycaster","_deltaTime","setTargetElement","domElement","globalPoint","root","processInteractive","element","removeEvents","addEvents","navigator","msPointerEnabled","style","document","snippet","didMove","k","hasOwnProperty","interactionData","interactionEvent","configureInteractionEventForDOMEvent","setCursorMode","mode","assign","displayObject","eventString","point","x","y","rect","parentElement","getBoundingClientRect","left","top","func","hitTest","visible","hit","interactiveParent","children","child","childHit","parent","events","normalizeToPointerData","isNormalized","preventDefault","getInteractionDataForPointerId","triggerEvent","eventLen","isRightButton","id","trackedPointers","rightDown","leftDown","cancelled","eventAppend","releaseInteractionDataForPointerId","onPointerComplete","trackingData","isTouch","isMouse","test","isDown","over","none","pop","_copyEvent","_reset","push","pointerEvent","mapPositionToPoint","clientX","clientY","setFromCamera","globalX","globalY","normalizedEvents","TouchEvent","li","changedTouches","touch","touches","radiusX","radiusY","force","layerX","offsetX","layerY","offsetY","MouseEvent","removeAllListeners","_tempPoint","lastTime","vendors","requestAnimationFrame","cancelAnimationFrame","callback","currTime","Date","getTime","timeToCall","Math","max","setTimeout","RAF","CAF","Ticker","timer","pt","start","loop","timeline","now","Interaction","autoAttach","ticker","update"],"mappings":"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"}